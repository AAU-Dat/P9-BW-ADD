\section{Experiments}\label{sec:experiments}
This section describes the experiment to evaluate the proposed symbolic implementation of the Baum-Welch algorithm in CuPAAL.
The experiment is designed to compare CuPAAL with one other implementation: Jajapy, the original matrix-based implementation.
The experiment is conducted to answer the following research question:

\begin{itemize}
\item \textbf{Question:} How does the scalability of the symbolic CuPAAL implementation compare to Jajapy and SUDD as the number of model states increases?
\end{itemize}

This question evaluates the computational efficiency of the symbolic implementation in CuPAAL. The insights gained will highlight the strengths and potential trade-offs of symbolic approaches to the Baum-Welch algorithm.

\subsection{Experimental Setup}
The experiment evaluates how each implementation scales with increasing model states. We conduct a single experiment to evaluate the proposed method.
The experiment is conducted on a machine with the specifications in \autoref{tab:machine-specs}. 
\begin{table}
\centering
\caption{Machine Specifications from AAU Strato}
\label{tab:machine-specs}
    \begin{tabular}{ll}
        \toprule
        \textbf{Component} & \textbf{Specification} \\
        \midrule
        CPU & AMD EPYC 16-core \\
        RAM & 64 GB \\
        DISK & 50 GB \\
        \bottomrule
    \end{tabular}
\end{table}

We use the following implementations for comparison:

\begin{itemize}
\item \textbf{Jajapy}: A matrix-based implementation of the Baum-Welch algorithm \cite{reynouard2023jajapy}.
\item \textbf{CuPAAL}: The fully symbolic implementation proposed in this work.
\end{itemize}

The chosen implementations progress from fully matrix-based to fully symbolic approaches, providing a comprehensive comparison of methodologies.

\subsection{Experiment dataset}
The experiment uses synthetic datasets; The dataset has five different labels \{"A", "B", "C", "D", "E"\} and the same observation sequence for all runs of the experiment. 
We use 10 observation sequences of length 10.
The number of states in the model is varied from 20 to 1020, with increments of 100 states.
The initial model is generated with random parameters, and the observation sequence is consistent across all runs.
The model always starts in the same initial state, and the transition matrix and emission matrix are generated randomly.
Where the emission matrix is generated such that one state can emit max three different labels.
All implementations are tested on the same dataset to ensure fair comparison.

\subsection{Experimental Procedure}
The experiment assesses how the runtime of each implementation changes as the number of states in a synthetic model increases from 20 to 1020. 
The process is repeated as follows:

\begin{enumerate}
\item Load the initial model and observation sequence.
\item Use each implementation of the Baum-Welch algorithm to estimate model parameters, recording runtime.
\item Increase the number of states in the model and run the Baum-Welch algorithm again.
\end{enumerate}

Scalability is evaluated by examining runtime trends as model size increases.
This provides insight into how each implementation scales with larger models and is critical for understanding the practical applicability of symbolic versus matrix-based implementations for large-scale problems.

Results will be visualized using plots to illustrate trends and highlight differences in scalability between implementations.

\subsection{Discussion of Metrics and Methods}
The runtime is the primary evaluation metric, as it directly reflects the computational efficiency of each implementation when handling larger models. By plotting runtime against the number of states, we aim to identify patterns and scalability limits for each approach.

\subsection{Reproducibility}
To ensure reproducibility, all datasets, source code, and experiment configurations will is publicly available in the reposetory here~\cite{p7}\footnote{The specific link \url{https://github.com/AAU-Dat/P7-sudd/blob/P9-experiments/scaling_experiment.py}}. 
Hardware specifications and software dependencies are documented to facilitate replication.

\begin{figure}
    \centering
    \input{figures/scalability_graph.tex}
    \caption{Scalability of Baum-Welch Implementations}
    \label{fig:scalability}
\end{figure}